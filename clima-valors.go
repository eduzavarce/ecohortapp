package main

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)
type PreUrl struct {
	Url string `json:"datos"`
	Client *http.Client
}
type AutoGenerated []struct {
	Origen     Origen     `json:"origen"`
	Elaborado  string     `json:"elaborado"`
	Nombre     string     `json:"nombre"`
	Provincia  string     `json:"provincia"`
	Prediccion Prediccion `json:"prediccion"`
	ID         int        `json:"id"`
	Version    float64    `json:"version"`
}
type Origen struct {
	Productor string `json:"productor"`
	Web       string `json:"web"`
	Enlace    string `json:"enlace"`
	Language  string `json:"language"`
	Copyright string `json:"copyright"`
	NotaLegal string `json:"notaLegal"`
}
type ProbPrecipitacion struct {
	Value   int    `json:"value"`
	Periodo string `json:"periodo"`
}
type CotaNieveProv struct {
	Value   string `json:"value"`
	Periodo string `json:"periodo"`
}
type EstadoCielo struct {
	Value       string `json:"value"`
	Periodo     string `json:"periodo"`
	Descripcion string `json:"descripcion"`
}
type Viento struct {
	Direccion string `json:"direccion"`
	Velocidad int    `json:"velocidad"`
	Periodo   string `json:"periodo"`
}
type RachaMax struct {
	Value   string `json:"value"`
	Periodo string `json:"periodo"`
}
type Dato struct {
	Value int `json:"value"`
	Hora  int `json:"hora"`
}
type Temperatura struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}
type SensTermica struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}
type HumedadRelativa struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}
type Dia struct {
	ProbPrecipitacion []ProbPrecipitacion `json:"probPrecipitacion"`
	CotaNieveProv     []CotaNieveProv     `json:"cotaNieveProv"`
	EstadoCielo       []EstadoCielo       `json:"estadoCielo"`
	Viento            []Viento            `json:"viento"`
	RachaMax          []RachaMax          `json:"rachaMax"`
	Temperatura       Temperatura         `json:"temperatura"`
	SensTermica       SensTermica         `json:"sensTermica"`
	HumedadRelativa   HumedadRelativa     `json:"humedadRelativa"`
	UvMax             int                 `json:"uvMax,omitempty"`
	Fecha             string              `json:"fecha"`
}
type Prediccion struct {
	Dia []Dia `json:"dia"`
}
type Diaria struct {
	ProbPrecipitacio int `json:"probPrecipitacion"`
	TemperaturaMax int `json:"maxima"`
	TemperaturaMin int `json:"minima"`
	HumitatRelativa int `json:"humedadRelativa"`
	Time time.Time `json:"-"`

}

func (g *Diaria) GetPrediccions () (*Diaria, error){
	url, _ := GetPreUrl()
	prediccion, error := getData(url)
	return prediccion, error


}

func GetPreUrl () (string, error) { // todo este rollo de pre url es por que hay que hacer dos peticiones a la api de AEMET porque es puñetera la api
	//Definir la url que atacaremos
	url := "https://opendata.aemet.es/opendata/api/prediccion/especifica/municipio/diaria/08001/?api_key=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJlZHV6YXZhcmNlQGdtYWlsLmNvbSIsImp0aSI6ImIxYzZiYmFhLTcyY2MtNGJiZS1iZmZkLTI3ZDU2ZjBlZjQ3ZiIsImlzcyI6IkFFTUVUIiwiaWF0IjoxNjkwNDc0NTY1LCJ1c2VySWQiOiJiMWM2YmJhYS03MmNjLTRiYmUtYmZmZC0yN2Q1NmYwZWY0N2YiLCJyb2xlIjoiIn0.6XDOSB6_eFLQwS28nsnDbf8DlPWuIxlk7FXVLwmmeHc"

	//Hacemos la petición

	req, _ := http.NewRequest("GET", url, nil) // http.NewRequest devuelve req, err , tenemos un _ en el error

	req.Header.Add("cache-control", "no-cache")

	res, err := http.DefaultClient.Do(req)

	if err != nil {
		log.Println("error conectando a la AEMET", err)
		return "", err //retornamos el error solo
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil{
		log.Println("error leyendo el JSON de la respuesta", err)
		return "", err //retornamos el error solo
	}
	preUrl := PreUrl{}
	err = json.Unmarshal(body, &preUrl)
	if err != nil{
		log.Println("error Unmarshal", err)
		return "", err //retornamos el error solo
	}
	return preUrl.Url, err //retorna la respuesta en caso de que todo vaya ok
}

func getData (url string) (*Diaria, error) {
	req, _ := http.NewRequest("GET", url, nil) // http.NewRequest devuelve req, err , tenemos un _ en el error

	req.Header.Add("cache-control", "no-cache")

	res, err := http.DefaultClient.Do(req)

	if err != nil{
		log.Println("error de conección")
		return nil, err
		}
	defer res.Body.Close()
		body, err := ioutil.ReadAll(res.Body)
	if err != nil{
		log.Println("error leyendo el JSON de la respuesta", err)
		return nil, err //retornamos el error solo
	}
	prediccion := AutoGenerated{}
	err = json.Unmarshal(body, &prediccion)
	if err != nil{
		log.Println("error parsing", err)
		return nil, err //retornamos el error solo
	}
	var precipitacio, tempMax, tempMin, humitat int
	
	precipitacio, tempMax, tempMin, humitat = prediccion[0].Prediccion.Dia[0].ProbPrecipitacion[0].Value, prediccion[0].Prediccion.Dia[0].Temperatura.Maxima, prediccion[0].Prediccion.Dia[0].Temperatura.Minima, prediccion[0].Prediccion.Dia[0].HumedadRelativa.Maxima
	 var data = Diaria{
		ProbPrecipitacio: precipitacio,
		TemperaturaMax: tempMax,
		TemperaturaMin: tempMin,
		HumitatRelativa: humitat,
	 }
	 
	return &data, err
}
